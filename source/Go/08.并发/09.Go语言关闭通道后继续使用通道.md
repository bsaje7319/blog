# 09.Go语言关闭通道后继续使用通道
通道是一个引用对象，和 map 类似。map 在没有任何外部引用时，Go语言程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection, GC）。类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。

格式
使用close()来关闭一个通道：
``` 
close(ch)
```
关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。


给被关闭通道发送数据将会触发 panic

被关闭的通道不会被置为 nil。如果尝试对已经关闭的通道进行发送，将会触发宕机，代码如下：

``` 
package main

import "fmt"

func main() {
	// 创建一个整型的通道
	ch := make(chan int)

	// 关闭通道
	//关闭通道，注意 ch 不会被 close 设置为 nil，依然可以被访问。
	close(ch)

	// 打印通道的指针，容量和长度,打印已经关闭通道的指针、容量和长度。
	fmt.Printf("ptr:%p cap:%d len:%d\n", ch, cap(ch), len(ch))
	//ptr:0xc000012180 cap:0 len:0
	//panic: send on closed channel
	// 给关闭的通道发送数据
	ch <- 1
}

```




## 从已关闭的通道接收数据时将不会发生阻塞

从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。

操作关闭后的通道：
``` 
package main

import "fmt"

func main() {
	// 创建一个整型带两个缓冲的通道
	ch := make(chan int, 2)

	// 给通道放入两个数据
	ch <- 0
	ch <- 1
	//关闭缓冲
	close(ch)
	// 遍历缓冲所有数据，且多遍历1个
	//cap() 函数可以获取一个对象的容量，这里获取的是带缓冲通道的容量，也就是这个通道在 make 时的大小。虽然此时这个通道的元素个数和容量都是相同的，但是 cap 取出的并不是元素个数。这里多遍历一个元素，故意造成这个通道的超界访问。
	for i := 0; i < cap(ch)+1; i++ {
		// 从通道中取出数据
		v, ok := <-ch

		//打印取出数据的状态
		fmt.Println(v, ok)
		/*
		0 true
		1 true
		0 false
		 */
	}
}
```