.. contents::
   :depth: 3
..

12.同步-保证并发环境下数据访问的正确性
======================================

有并发，就有资源竞争，如果两个或者多个 goroutine
在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写时，就会处于相互竞争的状态，这就是并发中的资源竞争。

并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。

竞态检测-检测代码在并发环境下可能出现的问题
-------------------------------------------

当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞态问题。

竞态检测

::

   package main

   import (
       "fmt"
       "sync/atomic"
   )

   var (
       // 序列号
       seq int64
   )

   // 序列号生成器
   func GenID() int64 {
       // 尝试原子的增加序列号
       atomic.AddInt64(&seq, 1)
       return seq
   }

   func main() {
       // 生成10个并发序列号
       for i := 0; i < 10; i++ {
           go GenID()
       }
       fmt.Println(GenID())
   }

本例中只是对变量进行增减操作，虽然可以使用互斥锁(sync.Mutex)解决竞态问题，但是对性能消耗较大。
推荐使用原子操作(atomic)进行变量操作。

::

   D:\go_studay\go_path\src\github.com\go_study02\03.并发\sample17>go run -race main.go
   10
