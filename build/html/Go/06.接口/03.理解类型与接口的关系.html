

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.3. 03.理解类型与接口的关系 &mdash; 系统化的学习Linux、Python、Shell、Java运维开发</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'1.0.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: ''
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="next" title="6.4. 04.常见的类型的便捷排序" href="04.常见的类型的便捷排序.html" />
    <link rel="prev" title="6.2. 02.实现接口的条件" href="02.实现接口的条件.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> 小健_Linux-Python-Devops_Blog
          

          
            
            <img src="../../_static/python_go.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Go语言学习</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../01.Go语言基本语法与使用/index.html">1. 01.Go语言基本语法与使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../02.容器-存储与组织数据的方式/index.html">2. 02.容器-存储与组织数据的方式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../03.流程控制/index.html">3. 03.流程控制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../04.函数/index.html">4. 04.函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../05.结构体/index.html">5. 05.结构体</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">6. 06.接口</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="01.声明接口.html">6.1. 01.声明接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="02.实现接口的条件.html">6.2. 02.实现接口的条件</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">6.3. 03.理解类型与接口的关系</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">6.3.1. 一个类型可以实现多个接口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">6.3.2. 多个类型和实现相同的接口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">6.3.3. 示例：便于扩展输出方式的日志系统</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">6.3.4. 示例：使用接口进行数据的排序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="04.常见的类型的便捷排序.html">6.4. 04.常见的类型的便捷排序</a></li>
<li class="toctree-l3"><a class="reference internal" href="05.对结构体数据进行排序.html">6.5. 05.对结构体数据进行排序</a></li>
<li class="toctree-l3"><a class="reference internal" href="06.接口的嵌套组合-将多个接口放在一个接口内.html">6.6. 06.接口的嵌套组合-将多个接口放在一个接口内</a></li>
<li class="toctree-l3"><a class="reference internal" href="07.在接口和类型间转换.html">6.7. 07.在接口和类型间转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="08.空接口类型(interface{})-能保存所有值的类型.html">6.8. 08.空接口类型(interface{})-能保存所有值的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="09.类型分支-批量判断空接口中变量的类型.html">6.9. 09.类型分支-批量判断空接口中变量的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="10.Go语言实现有限状态机(FSM).html">6.10. 10.Go语言实现有限状态机(FSM)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../07.包/index.html">7. 07.包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../08.并发/index.html">8. 08.并发</a></li>
<li class="toctree-l2"><a class="reference internal" href="../09.Go语言基础之反射/index.html">9. 09.Go语言基础之反射</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10.Go标准库/index.html">10. 10.Go标准库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11.项目代码/index.html">11. 项目代码</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Python/index.html">Python自动化运维</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">小健_Linux-Python-Devops_Blog</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Go语言学习</a> &raquo;</li>
        
          <li><a href="index.html">6. 06.接口</a> &raquo;</li>
        
      <li>6.3. 03.理解类型与接口的关系</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/Go/06.接口/03.理解类型与接口的关系.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id7">03.理解类型与接口的关系</a><ul>
<li><a class="reference internal" href="#id2" id="id8">一个类型可以实现多个接口</a></li>
<li><a class="reference internal" href="#id3" id="id9">多个类型和实现相同的接口</a><ul>
<li><a class="reference internal" href="#id4" id="id10">一个接口的简单示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5" id="id11">示例：便于扩展输出方式的日志系统</a></li>
<li><a class="reference internal" href="#id6" id="id12">示例：使用接口进行数据的排序</a><ul>
<li><a class="reference internal" href="#sort-interface" id="id13">使用sort.Interface接口进行排序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id7">6.3. 03.理解类型与接口的关系</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id8">6.3.1. 一个类型可以实现多个接口</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Socket</span> <span class="n">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">Socket</span><span class="p">)</span> <span class="n">Writer</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nil</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Socket</span><span class="p">)</span> <span class="n">Close</span><span class="p">()</span> <span class="n">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Socket结构的Writer实现了io.Writer接口：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Writer</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也实现了io.Closer接口:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Closer</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Close</span><span class="p">()</span> <span class="n">error</span>
<span class="p">}</span>
</pre></div>
</div>
<p><img alt="image0" src="../../_images/go_interface0001.png" /></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">usingWriter</span><span class="p">(</span><span class="n">writer</span> <span class="n">io</span><span class="o">.</span><span class="n">Writer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">usingCloser</span><span class="p">(</span><span class="n">closer</span> <span class="n">io</span><span class="o">.</span><span class="n">Closer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">closer</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">实例化Socket</span>
    <span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Socket</span><span class="p">)</span>
    <span class="n">usingWriter</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">usingCloser</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="p">}</span>
</pre></div>
</div>
<p>usingWriter()和usingCloser()完全独立，互相不知道对方的存在，也不知道自己使用的接口是Socket实现的。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">6.3.2. 多个类型和实现相同的接口</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span>package main

import (
    &quot;fmt&quot;
)

// 一个服务需要满足开启和写日志功能
type Service interface {
    Strat()     // 开启服务
    Log(string) // 日志输出
}

// 日志器
type Logger struct {
}

// 实现Service的Log()方法,为Logger添加Log()方法
func (g *Logger) Log(string2 string){
    fmt.Println(&quot;log info ............&quot;)
}

// 游戏服务
type GameService struct {
    Logger              // 嵌入Logger日志器，以实现日志功能
}

// 实现Service的Start()方法
func (g *GameService) Strat() {
    print(&quot;service is running&quot;)
}

func main() {
    var s Service = new(GameService)
    s.Strat()
    s.Log(&quot;hello&quot;)
}
</pre></div>
</div>
<p>s就可以使用Start()方法和Log()方法，其中,Start()由GameService实现，Log()方法由Logger实现。</p>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id10">一个接口的简单示例</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span>package main

import &quot;fmt&quot;

func main() {
    hu := keyboard{name: &quot;小健的键盘&quot;}
    fmt.Printf(&quot;设备的名称：%s\n&quot;, hu.name)
    hu.strat()
    hu.end()
    fmt.Println(&quot;------------------------------------------------&quot;)
    fmt.Println(&quot;------------------------------------------------&quot;)

    // 声明一个USB接口
    var ints USB
    m := new(mouse)
    ints = m
    ints.strat()
    ints.end()

    k :=new(keyboard)
    ints = k
    ints.strat()
    ints.end()

}


// USB接口
type USB interface {
    strat()
    end()
}

// 键盘结构体
type keyboard struct {
    name string // 键盘名称
}
// 键盘的方法，实现了接口中定义的方法
func (k *keyboard) strat() {
    fmt.Println(&quot;键盘开始工作.敲代码......&quot;)
}
func (k *keyboard) end() {
    fmt.Println(&quot;键盘结束工作&quot;)
}


// 鼠标结构体，实现了接口中定义的方法
type mouse struct {
    name string
}

func (m *mouse) strat() {
    fmt.Println(&quot;鼠标开始工作.敲代码......&quot;)
}

func (m *mouse) end() {
    fmt.Println(&quot;鼠标结束工作&quot;)
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id11">6.3.3. 示例：便于扩展输出方式的日志系统</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>搭建一个支持多种写入器的日志系统，可以扩展多种日志写入设备。</p>
<p>1.日志对外接口</p>
<p>logger.go</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>package main

// 声明日志写入器接口,这个接口可以被外部使用，实现一个日志的输出设备
type LogWriter interface {
    Write(data interface{}) error
}

// 日志器结构，使用writerList记录输出到哪个设备上
type Logger struct {

    // 这个日志器用到的日志写入器
    writerList []LogWriter
}

// 注册一个日志写入器，RegisterWriter()方法将日志写入器（LogWriter）注册到日志器（Logger）中
// 注册的意思就是将日志写入器的接口添加到writeList中
func (l *Logger) RegisterWriter(writer LogWriter) {
    l.writerList = append(l.writerList, writer)
}

// 将一个data类型的数据写入到日志
func (l *Logger) Log(data interface{}) {

    // 遍历所有注册的写入器
    for _, writer := range l.writerList {

        // 将日志输出到每一个写入器
        writer.Write(data)
    }
}

// 创建日志器的实例
func NewLogger() *Logger {
    return &amp;Logger{}
}
</pre></div>
</div>
<p>2.文件写入器</p>
<p>file.go</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

// 文件写入器
type fileWriter struct {
    file *os.File
}

// 设置文件写入器写入的文件名
func (f *fileWriter) SetFile(filename string) (err error) {

    // 如果文件已经打开，关闭前一个文件
    if f.file != nil {
        f.file.Close()
    }

    // 创建一个文件并保存文件句柄
    f.file, err = os.Create(filename)

    // 如果创建的过程出现错误，则返回错误
    return err
}

// 实现LogWriter的Write
func (f *fileWriter) Write(data interface{}) error {

    // 日志文件可能没有创建成功
    if f.file == nil {

        // 日志文件没有准备好
        return errors.New(&quot;file not created&quot;)
    }

    // 将数据序列化为字符串
    str := fmt.Sprintf(&quot;%v\n&quot;, data)

    // 将数据以字节数组写入到文件
    _, err := f.file.Write([]byte(str))

    return err
}

// 创建文件写入器实例
func newFileWriter() *fileWriter {
    return &amp;fileWriter{}
}
</pre></div>
</div>
<p>3.命令行写入器</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s2">&quot;fmt&quot;</span>
    <span class="s2">&quot;os&quot;</span>
<span class="p">)</span>

<span class="o">//</span> <span class="n">命令行写入器</span>
<span class="nb">type</span> <span class="n">consoleWriter</span> <span class="n">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">实现LogWriter的Write</span>
<span class="n">func</span> <span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">consoleWriter</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">data</span> <span class="n">interface</span><span class="p">{})</span> <span class="n">error</span> <span class="p">{</span>

    <span class="o">//</span> <span class="n">将数据序列化为字符串</span>
    <span class="nb">str</span> <span class="p">:</span><span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s2">&quot;%v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="o">//</span> <span class="n">将数据以字节数组写入到命令行</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="o">.</span><span class="n">Write</span><span class="p">([]</span><span class="n">byte</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">创建命令行写入器实例</span>
<span class="n">func</span> <span class="n">newConsoleWriter</span><span class="p">()</span> <span class="o">*</span><span class="n">consoleWriter</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">consoleWriter</span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>4.使用日志</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="s2">&quot;fmt&quot;</span>

<span class="o">//</span> <span class="n">创建日志器</span>
<span class="n">func</span> <span class="n">createLogger</span><span class="p">()</span> <span class="o">*</span><span class="n">Logger</span> <span class="p">{</span>

    <span class="o">//</span> <span class="n">创建日志器</span>
    <span class="n">l</span> <span class="p">:</span><span class="o">=</span> <span class="n">NewLogger</span><span class="p">()</span>
    <span class="o">//</span> <span class="n">创建命令行写入器</span>
    <span class="n">cw</span> <span class="p">:</span><span class="o">=</span> <span class="n">newConsoleWriter</span><span class="p">()</span>
    <span class="o">//</span> <span class="n">注册命令行写入器到日志器</span>
    <span class="n">l</span><span class="o">.</span><span class="n">RegisterWriter</span><span class="p">(</span><span class="n">cw</span><span class="p">)</span>



    <span class="o">//</span> <span class="n">创建文件写入器</span>
    <span class="n">fw</span> <span class="p">:</span><span class="o">=</span> <span class="n">newFileWriter</span><span class="p">()</span>
    <span class="o">//</span> <span class="n">设置文件名</span>
    <span class="k">if</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">fw</span><span class="o">.</span><span class="n">SetFile</span><span class="p">(</span><span class="s2">&quot;log.log&quot;</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">注册文件写入器到日志器</span>
    <span class="n">l</span><span class="o">.</span><span class="n">RegisterWriter</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="o">//</span> <span class="n">准备日志器</span>
    <span class="n">l</span> <span class="p">:</span><span class="o">=</span> <span class="n">createLogger</span><span class="p">()</span>

    <span class="o">//</span> <span class="n">写一个日志</span>
    <span class="n">l</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id12">6.3.4. 示例：使用接口进行数据的排序</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="nb">type</span> <span class="n">Interface</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="o">//</span> <span class="mi">3</span><span class="n">个方法</span>
    <span class="o">//</span> <span class="n">获取元素数量</span>
    <span class="n">Len</span><span class="p">()</span> <span class="nb">int</span>
    <span class="o">//</span> <span class="n">判断传入数值大小</span>
    <span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span> <span class="nb">bool</span>
    <span class="o">//</span> <span class="n">传入元素位置互换</span>
    <span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="sort-interface">
<h3><a class="toc-backref" href="#id13">使用sort.Interface接口进行排序</a><a class="headerlink" href="#sort-interface" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s2">&quot;fmt&quot;</span>
    <span class="s2">&quot;sort&quot;</span>
<span class="p">)</span>

<span class="o">//</span> <span class="n">将</span><span class="p">[]</span><span class="n">string定义为MyStringList类型</span>
<span class="nb">type</span> <span class="n">MyStringList</span> <span class="p">[]</span><span class="n">string</span>

<span class="o">//</span> <span class="n">实现sort</span><span class="o">.</span><span class="n">Interface接口的获取元素数量方法</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyStringList</span><span class="p">)</span> <span class="n">Len</span><span class="p">()</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">实现sort</span><span class="o">.</span><span class="n">Interface接口的比较元素方法</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyStringList</span><span class="p">)</span> <span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">实现sort</span><span class="o">.</span><span class="n">Interface接口的交换元素方法</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyStringList</span><span class="p">)</span> <span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="o">//</span> <span class="n">准备一个内容被打乱顺序的字符串切片</span>
    <span class="n">names</span> <span class="p">:</span><span class="o">=</span> <span class="n">MyStringList</span><span class="p">{</span>
        <span class="s2">&quot;3. Triple Kill&quot;</span><span class="p">,</span>
        <span class="s2">&quot;5. Penta Kill&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2. Double Kill&quot;</span><span class="p">,</span>
        <span class="s2">&quot;4. Quadra Kill&quot;</span><span class="p">,</span>
        <span class="s2">&quot;1. First Blood&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">使用sort包进行排序</span>
    <span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

    <span class="o">//</span> <span class="n">遍历打印结果</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">names</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">i</span> <span class="n">Interface</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">names</span>
<span class="o">//</span> <span class="n">切片总的大小</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">Len</span><span class="p">())</span>    <span class="o">//</span><span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="04.常见的类型的便捷排序.html" class="btn btn-neutral float-right" title="6.4. 04.常见的类型的便捷排序" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="02.实现接口的条件.html" class="btn btn-neutral float-left" title="6.2. 02.实现接口的条件" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, huxiaojian

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>